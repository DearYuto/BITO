/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customFetch } from './fetcher';
export interface SignupDto { [key: string]: unknown }

export interface LoginDto { [key: string]: unknown }

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export type appControllerGetHelloResponse200 = {
  data: void
  status: 200
}
    
export type appControllerGetHelloResponseSuccess = (appControllerGetHelloResponse200) & {
  headers: Headers;
};
;

export type appControllerGetHelloResponse = (appControllerGetHelloResponseSuccess)

export const getAppControllerGetHelloUrl = () => {


  

  return `/`
}

export const appControllerGetHello = async ( options?: RequestInit): Promise<appControllerGetHelloResponse> => {
  
  return customFetch<appControllerGetHelloResponse>(getAppControllerGetHelloUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAppControllerGetHelloQueryKey = () => {
    return [
    `/`
    ] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type appControllerGetHealthResponse200 = {
  data: void
  status: 200
}
    
export type appControllerGetHealthResponseSuccess = (appControllerGetHealthResponse200) & {
  headers: Headers;
};
;

export type appControllerGetHealthResponse = (appControllerGetHealthResponseSuccess)

export const getAppControllerGetHealthUrl = () => {


  

  return `/health`
}

export const appControllerGetHealth = async ( options?: RequestInit): Promise<appControllerGetHealthResponse> => {
  
  return customFetch<appControllerGetHealthResponse>(getAppControllerGetHealthUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAppControllerGetHealthQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getAppControllerGetHealthQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHealth>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHealth>>> = ({ signal }) => appControllerGetHealth({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHealth>>>
export type AppControllerGetHealthQueryError = unknown


export function useAppControllerGetHealth<TData = Awaited<ReturnType<typeof appControllerGetHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHealth>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHealth<TData = Awaited<ReturnType<typeof appControllerGetHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHealth>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHealth<TData = Awaited<ReturnType<typeof appControllerGetHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHealth>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHealth<TData = Awaited<ReturnType<typeof appControllerGetHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHealth>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type authControllerSignupResponse201 = {
  data: void
  status: 201
}
    
export type authControllerSignupResponseSuccess = (authControllerSignupResponse201) & {
  headers: Headers;
};
;

export type authControllerSignupResponse = (authControllerSignupResponseSuccess)

export const getAuthControllerSignupUrl = () => {


  

  return `/auth/signup`
}

export const authControllerSignup = async (signupDto: SignupDto, options?: RequestInit): Promise<authControllerSignupResponse> => {
  
  return customFetch<authControllerSignupResponse>(getAuthControllerSignupUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      signupDto,)
  }
);}




export const getAuthControllerSignupMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignup>>, TError,{data: SignupDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSignup>>, TError,{data: SignupDto}, TContext> => {

const mutationKey = ['authControllerSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSignup>>, {data: SignupDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerSignup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSignupMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSignup>>>
    export type AuthControllerSignupMutationBody = SignupDto
    export type AuthControllerSignupMutationError = unknown

    export const useAuthControllerSignup = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignup>>, TError,{data: SignupDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSignup>>,
        TError,
        {data: SignupDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerSignupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type authControllerLoginResponse201 = {
  data: void
  status: 201
}
    
export type authControllerLoginResponseSuccess = (authControllerLoginResponse201) & {
  headers: Headers;
};
;

export type authControllerLoginResponse = (authControllerLoginResponseSuccess)

export const getAuthControllerLoginUrl = () => {


  

  return `/auth/login`
}

export const authControllerLogin = async (loginDto: LoginDto, options?: RequestInit): Promise<authControllerLoginResponse> => {
  
  return customFetch<authControllerLoginResponse>(getAuthControllerLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginDto,)
  }
);}




export const getAuthControllerLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    export type AuthControllerLoginMutationBody = LoginDto
    export type AuthControllerLoginMutationError = unknown

    export const useAuthControllerLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type authControllerMeResponse200 = {
  data: void
  status: 200
}
    
export type authControllerMeResponseSuccess = (authControllerMeResponse200) & {
  headers: Headers;
};
;

export type authControllerMeResponse = (authControllerMeResponseSuccess)

export const getAuthControllerMeUrl = () => {


  

  return `/auth/me`
}

export const authControllerMe = async ( options?: RequestInit): Promise<authControllerMeResponse> => {
  
  return customFetch<authControllerMeResponse>(getAuthControllerMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAuthControllerMeQueryKey = () => {
    return [
    `/auth/me`
    ] as const;
    }

    
export const getAuthControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) => authControllerMe({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeQueryError = unknown


export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type walletControllerGetBalanceResponse200 = {
  data: void
  status: 200
}
    
export type walletControllerGetBalanceResponseSuccess = (walletControllerGetBalanceResponse200) & {
  headers: Headers;
};
;

export type walletControllerGetBalanceResponse = (walletControllerGetBalanceResponseSuccess)

export const getWalletControllerGetBalanceUrl = () => {


  

  return `/wallet/balance`
}

export const walletControllerGetBalance = async ( options?: RequestInit): Promise<walletControllerGetBalanceResponse> => {
  
  return customFetch<walletControllerGetBalanceResponse>(getWalletControllerGetBalanceUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getWalletControllerGetBalanceQueryKey = () => {
    return [
    `/wallet/balance`
    ] as const;
    }

    
export const getWalletControllerGetBalanceQueryOptions = <TData = Awaited<ReturnType<typeof walletControllerGetBalance>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWalletControllerGetBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof walletControllerGetBalance>>> = ({ signal }) => walletControllerGetBalance({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WalletControllerGetBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof walletControllerGetBalance>>>
export type WalletControllerGetBalanceQueryError = unknown


export function useWalletControllerGetBalance<TData = Awaited<ReturnType<typeof walletControllerGetBalance>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetBalance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerGetBalance>>,
          TError,
          Awaited<ReturnType<typeof walletControllerGetBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerGetBalance<TData = Awaited<ReturnType<typeof walletControllerGetBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetBalance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerGetBalance>>,
          TError,
          Awaited<ReturnType<typeof walletControllerGetBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerGetBalance<TData = Awaited<ReturnType<typeof walletControllerGetBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useWalletControllerGetBalance<TData = Awaited<ReturnType<typeof walletControllerGetBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getWalletControllerGetBalanceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type marketControllerGetTickerResponse200 = {
  data: void
  status: 200
}
    
export type marketControllerGetTickerResponseSuccess = (marketControllerGetTickerResponse200) & {
  headers: Headers;
};
;

export type marketControllerGetTickerResponse = (marketControllerGetTickerResponseSuccess)

export const getMarketControllerGetTickerUrl = () => {


  

  return `/market/ticker`
}

export const marketControllerGetTicker = async ( options?: RequestInit): Promise<marketControllerGetTickerResponse> => {
  
  return customFetch<marketControllerGetTickerResponse>(getMarketControllerGetTickerUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMarketControllerGetTickerQueryKey = () => {
    return [
    `/market/ticker`
    ] as const;
    }

    
export const getMarketControllerGetTickerQueryOptions = <TData = Awaited<ReturnType<typeof marketControllerGetTicker>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetTicker>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMarketControllerGetTickerQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof marketControllerGetTicker>>> = ({ signal }) => marketControllerGetTicker({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetTicker>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MarketControllerGetTickerQueryResult = NonNullable<Awaited<ReturnType<typeof marketControllerGetTicker>>>
export type MarketControllerGetTickerQueryError = unknown


export function useMarketControllerGetTicker<TData = Awaited<ReturnType<typeof marketControllerGetTicker>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetTicker>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof marketControllerGetTicker>>,
          TError,
          Awaited<ReturnType<typeof marketControllerGetTicker>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarketControllerGetTicker<TData = Awaited<ReturnType<typeof marketControllerGetTicker>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetTicker>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof marketControllerGetTicker>>,
          TError,
          Awaited<ReturnType<typeof marketControllerGetTicker>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarketControllerGetTicker<TData = Awaited<ReturnType<typeof marketControllerGetTicker>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetTicker>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMarketControllerGetTicker<TData = Awaited<ReturnType<typeof marketControllerGetTicker>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetTicker>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMarketControllerGetTickerQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type marketControllerGetOrderbookResponse200 = {
  data: void
  status: 200
}
    
export type marketControllerGetOrderbookResponseSuccess = (marketControllerGetOrderbookResponse200) & {
  headers: Headers;
};
;

export type marketControllerGetOrderbookResponse = (marketControllerGetOrderbookResponseSuccess)

export const getMarketControllerGetOrderbookUrl = () => {


  

  return `/market/orderbook`
}

export const marketControllerGetOrderbook = async ( options?: RequestInit): Promise<marketControllerGetOrderbookResponse> => {
  
  return customFetch<marketControllerGetOrderbookResponse>(getMarketControllerGetOrderbookUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMarketControllerGetOrderbookQueryKey = () => {
    return [
    `/market/orderbook`
    ] as const;
    }

    
export const getMarketControllerGetOrderbookQueryOptions = <TData = Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMarketControllerGetOrderbookQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof marketControllerGetOrderbook>>> = ({ signal }) => marketControllerGetOrderbook({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MarketControllerGetOrderbookQueryResult = NonNullable<Awaited<ReturnType<typeof marketControllerGetOrderbook>>>
export type MarketControllerGetOrderbookQueryError = unknown


export function useMarketControllerGetOrderbook<TData = Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof marketControllerGetOrderbook>>,
          TError,
          Awaited<ReturnType<typeof marketControllerGetOrderbook>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarketControllerGetOrderbook<TData = Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof marketControllerGetOrderbook>>,
          TError,
          Awaited<ReturnType<typeof marketControllerGetOrderbook>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarketControllerGetOrderbook<TData = Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMarketControllerGetOrderbook<TData = Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketControllerGetOrderbook>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMarketControllerGetOrderbookQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
